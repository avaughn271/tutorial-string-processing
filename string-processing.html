<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>String Processing</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>String Processing</h1>

<h2>Manipulating Text Data in R and Python, including Regular Expressions </h2>

<p>Chris Paciorek, Department of Statistics, UC Berkeley</p>

<h1>0) This Tutorial</h1>

<p>This tutorial covers tools for manipulating text data in R and Python, including the use of regular expressions. We also briefly discuss tools for reading and manipulating formatted text files such as HTML, XML, and JSON. At the moment, this tutorial is somewhat more focused on R than Python, but we hope to flesh out the Python sections more fully in the future.</p>

<p>In the future, a screencast of the material may accompany this document.</p>

<p>We&#39;ll use a virtual machine developed here at Berkeley, the <a href="http://bce.berkeley.edu">Berkeley Common Environment (BCE)</a>. BCE is a virtual Linux machine - basically it is a Linux computer that you can run within your own computer, regardless of whether you are using Windows, Mac, or Linux. This provides a common environment so that things behave the same for all of us.  However, if you have a standard R or Python installation and can install <em>stringr</em> for R and <em>re</em> for Python, that should work too.</p>

<p>This tutorial assumes you have a working knowledge of R or Python. </p>

<p>Materials for this tutorial, including the R markdown file and associated code files that were used to create this document are available on Github at (<a href="https://github.com/berkeley-scf/tutorial-string-processing">https://github.com/berkeley-scf/tutorial-string-processing</a>).  You can download the files by doing a git clone from a terminal window on a UNIX-like machine, as follows:</p>

<pre><code class="r">git clone https://github.com/berkeley-scf/tutorial-string-processing
</code></pre>

<p>To create this HTML document, simply compile the corresponding R Markdown file in R as follows (the following will work from within BCE after cloning the repository as above).</p>

<pre><code class="r">Rscript -e &quot;library(knitr); knit2html(&#39;string-processing.Rmd&#39;)&quot;
</code></pre>

<p>This tutorial by Christopher Paciorek is licensed under a Creative Commons Attribution 3.0 Unported License.</p>

<h1>1) Background</h1>

<p>Text manipulations in R, Python, Perl, and bash have a number of things 
in common, as many of these evolved from UNIX. When I use the
term <em>string</em> here, I&#39;ll be referring to any sequence of characters
that may include numbers, white space, and special characters. Note that in R
a character vector is a vector of one or more such strings.  </p>

<h1>2) Basic text manipulation</h1>

<p>Some of the basic things we need to do are paste/concatenate strings together,
split strings apart, take subsets of strings, and replace characters within strings.
Often these operations are done based on patterns rather than a fixed string 
sequence. This involves the use of regular expressions, covered in Section 3.</p>

<h2>2.1) R</h2>

<p>In general, strings in R are stored in character vectors. R&#39;s functions for string manipulation are fully vectorized and will work on all of the strings in a vector at once.</p>

<h3>2.1.1) String manipulation in base R</h3>

<p>A few of the basic R functions for manipulating strings are <em>paste</em>,
<em>strsplit</em>, and <em>substring</em>. <em>paste</em> and <em>strsplit</em>
are basically inverses of each other: <em>paste</em> concatenates
together an arbitrary set of strings (or a vector, if using the <em>collapse</em>
argument) with a user-specified separator character, while <em>strsplit</em>
splits apart based on a delimiter/separator. <em>substring</em>
splits apart the elements of a character vector based on fixed widths.
<em>nchar</em> returns the number of characters in a string.
Note that all of these operate in a vectorized fashion.</p>

<pre><code class="r">out &lt;- paste(&quot;My&quot;, &quot;name&quot;, &quot;is&quot;, &quot;Chris&quot;, &quot;.&quot;, sep = &quot; &quot;)
paste(c(&quot;My&quot;, &quot;name&quot;, &quot;is&quot;, &quot;Chris&quot;, &quot;.&quot;), collapse = &quot; &quot;) # equivalent
</code></pre>

<pre><code>## [1] &quot;My name is Chris .&quot;
</code></pre>

<pre><code class="r">strsplit(out, split = &#39; &#39;)
</code></pre>

<pre><code>## [[1]]
## [1] &quot;My&quot;    &quot;name&quot;  &quot;is&quot;    &quot;Chris&quot; &quot;.&quot;
</code></pre>

<pre><code class="r">nchar(out)
</code></pre>

<pre><code>## [1] 18
</code></pre>

<p>Note that <em>strsplit</em> returns a list because it can operate
on a character vector (i.e., on multiple strings).</p>

<pre><code class="r">vars &lt;- c(&quot;P&quot;, &quot;HCA24&quot;, &quot;SOH02&quot;)
substring(vars, 2, 3)
</code></pre>

<pre><code>## [1] &quot;&quot;   &quot;CA&quot; &quot;OH&quot;
</code></pre>

<pre><code class="r">substring(vars, 2, 3) &lt;- &#39;ZZ&#39;
</code></pre>

<p>To identify particular subsequences in strings, there are several
related R functions. <em>grep</em> will look for a specified string
within an R character vector and report back indices identifying the
elements of the vector in which the string was found. Note that using the
<code>fixed=TRUE</code> argument ensures that regular expressions are NOT
used. <em>gregexpr</em> will indicate the position in each string
that the specified string is found (use <em>regexpr</em> if you only
want the first occurrence). <em>gsub</em> can be used to replace a
specified string with a replacement string (use <em>sub</em> if you
only want to replace only the first occurrence). </p>

<pre><code class="r">vars &lt;- c(&quot;date98&quot;, &quot;size98&quot;, &quot;x98weights98&quot;, &quot;sdfsd&quot;)
grep(&quot;98&quot;, vars)
</code></pre>

<pre><code>## [1] 1 2 3
</code></pre>

<pre><code class="r">gregexpr(&quot;98&quot;, vars)
</code></pre>

<pre><code>## [[1]]
## [1] 5
## attr(,&quot;match.length&quot;)
## [1] 2
## attr(,&quot;useBytes&quot;)
## [1] TRUE
## 
## [[2]]
## [1] 5
## attr(,&quot;match.length&quot;)
## [1] 2
## attr(,&quot;useBytes&quot;)
## [1] TRUE
## 
## [[3]]
## [1]  2 11
## attr(,&quot;match.length&quot;)
## [1] 2 2
## attr(,&quot;useBytes&quot;)
## [1] TRUE
## 
## [[4]]
## [1] -1
## attr(,&quot;match.length&quot;)
## [1] -1
## attr(,&quot;useBytes&quot;)
## [1] TRUE
</code></pre>

<pre><code class="r">gsub(&quot;98&quot;, &quot;04&quot;, vars)
</code></pre>

<pre><code>## [1] &quot;date04&quot;       &quot;size04&quot;       &quot;x04weights04&quot; &quot;sdfsd&quot;
</code></pre>

<h3>2.1.2) String manipulation using <em>stringr</em></h3>

<p>The <em>stringr</em> package wraps the various core string manipulation
functions to provide a common interface. It also removes some of the
clunkiness involved in some of the string operations with the base
string functions, such as having to to call <em>gregexpr</em> and
then <em>regmatches</em> to pull out the matched strings. In general, I&#39;d suggest using <em>stringr</em> functions
in place of R&#39;s base string functions.</p>

<p>First let&#39;s see <em>stringr</em>&#39;s versions of some of the base string functions mentioned in the previous sections.</p>

<p>The basic interface to <em>stringr</em> functions is <code>function(strings, pattern, [replacement])</code>. </p>

<p>Table 1 provides an overview of the key functions related to working with patterns, which are basically
wrappers for <em>grep</em>, <em>gsub</em>, <em>gregexpr</em>, etc.</p>

<table><thead>
<tr>
<th>Function</th>
<th>What it does</th>
</tr>
</thead><tbody>
<tr>
<td>str_detect</td>
<td>detects pattern, returning TRUE/FALSE</td>
</tr>
<tr>
<td>str_count</td>
<td>counts matches</td>
</tr>
<tr>
<td>str_locate/str_locate_all</td>
<td>detects pattern, returning positions of matching characters</td>
</tr>
<tr>
<td>str_extract/str_extract_all</td>
<td>detects pattern, returning matches</td>
</tr>
<tr>
<td>str_replace/str_replace_all</td>
<td>detects pattern and replaces matches</td>
</tr>
</tbody></table>

<p>The analogue of <em>regexpr</em> vs. <em>gregexpr</em> and <em>sub</em>
vs. <em>gsub</em> is that most of the functions have versions that
return all the matches, not just the first match, e.g. <em>str_locate_all</em>
<em>str_extract_all</em>, etc. Note that the <em>_all</em> functions return
lists while the non-<em>_all</em> functions return vectors.</p>

<p>To specify options, you can wrap these functions around the pattern
argument: <code>fixed(pattern, ignore_case)</code> and <code>regex(pattern, ignore_case)</code>.
The default is <em>regex</em>, so you only need to specify that if you also want to 
specify additional arguments, such as <em>ignore_case</em> or others listed under <code>help(regex)</code> (invoke the help after loading <em>stringr</em>)</p>

<p>Here&#39;s an example:</p>

<pre><code class="r">library(stringr)
str &lt;- c(&quot;Apple&quot;, &quot;Basic&quot;, &quot;applied&quot;)
str_locate(str, fixed(&quot;app&quot;, ignore_case = TRUE))
</code></pre>

<pre><code>##      start end
## [1,]     1   3
## [2,]    NA  NA
## [3,]     1   3
</code></pre>

<pre><code class="r">str_locate(str, &quot;a{1}[a-z]{2}&quot;)
</code></pre>

<pre><code>##      start end
## [1,]    NA  NA
## [2,]     2   4
## [3,]     1   3
</code></pre>

<h2>2.2) Basic text manipulation in Python</h2>

<p>Let&#39;s see basic concatenation, splitting, working with substrings, and searching/replacing 
substrings. Notice that Python&#39;s string functionality is object-oriented (though <em>len</em> is not).
Note: apologies for all the extra print statements in the code - this is required when running Python
chunks in R Markdown.</p>

<pre><code class="python">print( &quot;My&quot; + &quot;name&quot; + &quot;is&quot; + &quot;Chris&quot; +  &quot;.&quot; )
out = &#39; &#39;.join((&quot;My&quot;, &quot;name&quot;, &quot;is&quot;, &quot;Chris&quot;, &quot;.&quot;))
print(out)
print( len(out) )
print( out.split(&#39; &#39;) )
</code></pre>

<pre><code>## MynameisChris.
## My name is Chris .
## 18
## [&#39;My&#39;, &#39;name&#39;, &#39;is&#39;, &#39;Chris&#39;, &#39;.&#39;]
</code></pre>

<p>In IPython, hitting tab after typing <code>out.</code> when <em>out</em> is a string will show the full suite of string-related methods.</p>

<p>Unlike in R, you cannot use the string methods directly on a list or tuple of strings, but you of course can do things like list comprehension to easily process multiple strings.</p>

<p>Working with substrings relies on the fact that Python works with strings as if they are vectors of individual characters.</p>

<pre><code class="python">var = &quot;HCA24&quot;
print( var[1:3] )
</code></pre>

<pre><code>## CA
</code></pre>

<p>However strings are immutable - you cannot alter a subset of characters in the string. Another option is to work with strings as lists.</p>

<pre><code class="python">var = list(&quot;HCA24&quot;)
print( var )
var[1:3] = [&quot;Z&quot;, &quot;Z&quot;]
print( &#39;&#39;.join(var) )
</code></pre>

<pre><code>## [&#39;H&#39;, &#39;C&#39;, &#39;A&#39;, &#39;2&#39;, &#39;4&#39;]
## HZZ24
</code></pre>

<p>Now let&#39;s consider finding substrings.</p>

<pre><code class="python">vars = [&quot;xxx98weights98&quot;, &quot;blah&quot;]
print( vars[0].find(&#39;98&#39;) )
print( vars[1].find(&#39;98&#39;) )
print( [v.find(&#39;98&#39;) for v in vars] )
</code></pre>

<pre><code>## 3
## -1
## [3, -1]
</code></pre>

<h1>3) Regular expressions (regex/regexp)</h1>

<p>Regular expressions are a domain-specific language for
finding patterns and are one of the key functionalities in scripting
languages such as Perl and Python, as well as the UNIX utilities <em>sed</em>,
<em>awk</em> and <em>grep</em>. </p>

<p>The basic idea of regular expressions is that they allow us to find
matches of strings or patterns in strings, as well as do substitution.
Regular expressions are good for tasks such as:</p>

<ul>
<li>extracting pieces of text - for example finding all the links in an html document;</li>
<li> creating variables from information found in text;</li>
<li> cleaning and transforming text into a uniform format;</li>
<li> mining text by treating documents as data; and</li>
<li> scraping the web for data.</li>
</ul>

<p>Please look at Section 3 of <a href="http://statistics.berkeley.edu/computing/training/tutorials">our tutorial on using the bash shell</a> to learn the regular expression syntax that we&#39;ll use in the remainder of this tutorial. For other resources, Duncan Temple Lang (UC Davis Statistics)
has written a nice tutorial that is part of the repository for this tutorial 
or check out Sections 9.9 and 11 of <a href="http://www.stat.auckland.ac.nz/%7Epaul/ItDT">Paul Murrell&#39;s book</a></p>

<h2>3.1) Versions of regular expressions</h2>

<p>One thing that can cause headaches is differences in version of regular expression syntax used. As discussed in <code>man grep</code>, <em>extended regular expressions</em> are standard, with <em>basic regular expressions</em> providing somewhat less functionality and <em>Perl regular expressions</em> additional functionality. 
As can be seen in <code>help(regex)</code>, In R, <em>stringr</em> provides <em>ICU regular expressions</em>, which are based on Perl regular expressions. More details can be found in the <a href="https://en.wikipedia.org/wiki/Regular_expression">regex Wikipedia page</a>.</p>

<p>The tutorial on using bash provides a full documentation of the various <em>extended regular expressions</em> syntax, which we&#39;ll focus on here. This should be sufficient for most usage and should be usable in R and Python, but if you notice something funny going on, it might be due to differences between the regular expressions versions. </p>

<h2>3.2) General principles for working with regex</h2>

<p>The syntax is very concise, so it&#39;s helpful to break down
individual regular expressions into the component parts to understand
them. As Murrell notes, since regex are their own language, it&#39;s
a good idea to build up a regex in pieces as a way of avoiding errors
just as we would with any computer code. <em>str_detect</em> in R&#39;s <em>stringr</em> and <em>re.findall</em> in Python are particularly
useful in seeing <em>what</em> was matched to help in understanding
and learning regular expression syntax and debugging your regex. As with
many kinds of coding, I find that debugging my regex is usually what takes
most of my time.</p>

<h2>3.1) Using regex in R</h2>

<p>The <em>grep</em>, <em>gregexpr</em> and <em>gsub</em> functions and
their <em>stringr</em> analogs are more powerful when used with regular
expressions. In the following examples, we&#39;ll illustrate usage of <em>stringr</em> functions, but 
with their base R analogs as comments.</p>

<p>First let&#39;s see the use of character sets and characters classes.</p>

<pre><code class="r">addresses &lt;- c(&quot;john@att.com&quot;, &quot;stat243@bspace.berkeley.edu&quot;, &quot;john_smith@att.com&quot;)
str_detect(addresses, &quot;[[:digit:]_]&quot;)
</code></pre>

<pre><code>## [1] FALSE  TRUE  TRUE
</code></pre>

<pre><code class="r">## grep(&quot;[[:digit:]_]&quot;, addresses, perl = TRUE)
</code></pre>

<pre><code class="r">text &lt;- c(&quot;john&quot;,&quot;jennifer Pierce&quot;,&quot;Juan carlos rey&quot;)
str_detect(text, &quot;[ \t]&quot;)
</code></pre>

<pre><code>## [1] FALSE  TRUE  TRUE
</code></pre>

<pre><code class="r">## grep(&quot;[ \t]&quot;, text)
str_locate_all(text, &quot;[ \t]&quot;)
</code></pre>

<pre><code>## [[1]]
##      start end
## 
## [[2]]
##      start end
## [1,]     9   9
## 
## [[3]]
##      start end
## [1,]     5   5
## [2,]    12  12
</code></pre>

<pre><code class="r">## gregexpr(&quot;[ \t]&quot;, text)
str_extract_all(text, &quot;^[[:upper:]][[:lower:]]+ &quot;)
</code></pre>

<pre><code>## [[1]]
## character(0)
## 
## [[2]]
## character(0)
## 
## [[3]]
## [1] &quot;Juan &quot;
</code></pre>

<pre><code class="r">## matches &lt;- gregexpr(&quot;^[[:upper:]][[:lower:]]+ &quot;, text)
## regmatches(text, matches)
str_replace_all(text, &quot;^j&quot;, &quot;J&quot;)
</code></pre>

<pre><code>## [1] &quot;John&quot;            &quot;Jennifer Pierce&quot; &quot;Juan carlos rey&quot;
</code></pre>

<pre><code class="r">## gsub(&quot;^j&quot;, &quot;J&quot;, text)
</code></pre>

<p>Challenge: how would we find a spam-like pattern with digits or non-letters inside a word? E.g., I want to find &ldquo;V1agra&rdquo; or &ldquo;Fancy repl!c@ted watches&rdquo;.</p>

<p>Next let&#39;s consider location-specific matches.</p>

<pre><code class="r">text &lt;- c(&quot;john&quot;,&quot;jennifer Pierce&quot;,&quot;Juan carlos rey&quot;)
str_detect(text, &quot;^[[:upper:]]&quot;) # text starting with upper case letter
</code></pre>

<pre><code>## [1] FALSE FALSE  TRUE
</code></pre>

<pre><code class="r">## grep(&quot;^[[:upper:]]&quot;, text) 
str_detect(text, &quot;e$&quot;) # text with a number at the end
</code></pre>

<pre><code>## [1] FALSE  TRUE FALSE
</code></pre>

<pre><code class="r">## grep(&quot;e$&quot;, text) 
</code></pre>

<p>Now let&#39;s make use of repetitions.</p>

<p>Here&#39;s a search for US/Canadian/Caribbean phone numbers: </p>

<pre><code class="r">text &lt;- c(&quot;Here&#39;s my number: 919-543-3300.&quot;, &quot;hi John, good to meet you&quot;,
          &quot;They bought 731 bananas&quot;, &quot;Please call 919.554.3800&quot;)
pattern &lt;- &quot;[[:digit:]]{3}[-\\.][[:digit:]]{3}[-\\.][[:digit:]]{4}&quot;
str_extract_all(text, pattern)
</code></pre>

<pre><code>## [[1]]
## [1] &quot;919-543-3300&quot;
## 
## [[2]]
## character(0)
## 
## [[3]]
## character(0)
## 
## [[4]]
## [1] &quot;919.554.3800&quot;
</code></pre>

<pre><code class="r">## matches &lt;- gregexpr(pattern, text)
## regmatches(text, matches)
</code></pre>

<p>Challenge: How would I extract an email address from an arbitrary text string?</p>

<p>Next consider grouping.</p>

<p>For example, the phone number detection problem could have been done a bit more compactly (and more generally, in case the area code is omitted or a 1 is included) as:</p>

<pre><code class="r">str_extract_all(text, &quot;(1[-\\.])?([[:digit:]]{3}[-\\.]){1,2}[[:digit:]]{4}&quot;)
</code></pre>

<pre><code>## [[1]]
## [1] &quot;919-543-3300&quot;
## 
## [[2]]
## character(0)
## 
## [[3]]
## character(0)
## 
## [[4]]
## [1] &quot;919.554.3800&quot;
</code></pre>

<pre><code class="r">## matches &lt;- gregexpr(&quot;(1[-\\.])?([[:digit:]]{3}[-\\.]){1,2}[[:digit:]]{4}&quot;, text)

## regmatches(text, matches)
</code></pre>

<pre><code class="r">text &lt;- c(&quot;at the site http://www.ibm.com&quot;, &quot;other text&quot;, &quot;ftp://ibm.com&quot;)
str_locate(text, &quot;(http|ftp):\\/\\/&quot;)
</code></pre>

<pre><code>##      start end
## [1,]    13  19
## [2,]    NA  NA
## [3,]     1   6
</code></pre>

<pre><code class="r">## gregexpr(&quot;(http|ftp):\\/\\/&quot;, text)
</code></pre>

<p>And reference back to a detected pattern when doing a replacement.</p>

<pre><code class="r">text &lt;- (&#39;&quot;H4NY07011&quot;,&quot;ACKERMAN, GARY L.&quot;,&quot;H&quot;,&quot;$13,242&quot;,,,&#39;)
clean_text &lt;- str_replace_all(text, &quot;([^\&quot;,]),&quot;, &quot;\\1&quot;)
clean_text
</code></pre>

<pre><code>## [1] &quot;\&quot;H4NY07011\&quot;,\&quot;ACKERMAN GARY L.\&quot;,\&quot;H\&quot;,\&quot;$13242\&quot;,,,&quot;
</code></pre>

<pre><code class="r">cat(clean_text)
</code></pre>

<pre><code>## &quot;H4NY07011&quot;,&quot;ACKERMAN GARY L.&quot;,&quot;H&quot;,&quot;$13242&quot;,,,
</code></pre>

<pre><code class="r">## gsub(&quot;([^\&quot;,]),&quot;, &quot;\\1&quot;, text)
</code></pre>

<p>Challenge: Suppose a text string has dates in the form “Aug-3”, “May-9”, etc. and I want them in the form “3 Aug”, “9 May”, etc. How would I do this search/replace?</p>

<p>Finally let&#39;s consider greedy matching.</p>

<pre><code class="r">text &lt;- &quot;Do an internship &lt;b&gt; in place &lt;/b&gt; of &lt;b&gt; one &lt;/b&gt; course.&quot;
str_replace_all(text, &quot;&lt;.*&gt;&quot;, &quot;&quot;)
</code></pre>

<pre><code>## [1] &quot;Do an internship  course.&quot;
</code></pre>

<pre><code class="r">## gsub(&quot;&lt;.*&gt;&quot;, &quot;&quot;, text)
</code></pre>

<p>What went wrong?</p>

<p>One solution is to append a ? to the repetition syntax to cause the matching to be non-greedy. Here&#39;s an example.</p>

<pre><code class="r">str_replace_all(text, &quot;&lt;.*?&gt;&quot;, &quot;&quot;)
</code></pre>

<pre><code>## [1] &quot;Do an internship  in place  of  one  course.&quot;
</code></pre>

<pre><code class="r">## gsub(&quot;&lt;.*?&gt;&quot;, &quot;&quot;, text)
</code></pre>

<p>However, one can often avoid greedy matching by being more clever. </p>

<p>Challenge: How could we change our regexp to avoid the greedy matching without using the “?”?</p>

<p>Regular expression can be used in a variety of places. E.g., to split by any number of white space characters</p>

<pre><code class="r">line &lt;- &quot;a dog\tjumped\nover \tthe moon.&quot;
cat(line)
</code></pre>

<pre><code>## a dog    jumped
## over     the moon.
</code></pre>

<pre><code class="r">str_split(line, &quot;[[:space:]]+&quot;)
</code></pre>

<pre><code>## [[1]]
## [1] &quot;a&quot;      &quot;dog&quot;    &quot;jumped&quot; &quot;over&quot;   &quot;the&quot;    &quot;moon.&quot;
</code></pre>

<pre><code class="r">str_split(line, &quot;[[:blank:]]+&quot;)
</code></pre>

<pre><code>## [[1]]
## [1] &quot;a&quot;            &quot;dog&quot;          &quot;jumped\nover&quot; &quot;the&quot;         
## [5] &quot;moon.&quot;
</code></pre>

<h2>3.2) Using regex in Python</h2>

<h3>3.2.1) Working with patterns</h3>

<p>For working with regex in Python, we&#39;ll need the <em>re</em> package. It provides Perl-style regular expressions, but it doesn&#39;t seem to support named character classes such as <code>[:digit:]</code>. Instead use classes such as <code>\d</code> and <code>[0-9]</code>.</p>

<p>Again, in the code chunks that follow, all the explicit print statements are needed for R Markdown to print out the values.</p>

<p>In Python, you apply a matching function and then query the result to get information about what was matched and where in the string. </p>

<pre><code class="python">import re
addresses = [&quot;john@att.com&quot;, &quot;stat243@bspace.berkeley.edu&quot;, 
  &quot;john_smith3@att.com&quot;]
m = re.search(&quot;[\d_]+&quot;, addresses[1])
print( m.group() )
print( m.start() )
print( m.end() )
print( m.span() )
</code></pre>

<pre><code>## 243
## 4
## 7
## (4, 7)
</code></pre>

<pre><code class="python">import re
addresses = [&quot;john@att.com&quot;, &quot;stat243@bspace.berkeley.edu&quot;, 
  &quot;john_smith3@att.com&quot;]
m = re.search(&quot;[\d_]+&quot;, addresses[2])
print( m.group() )
print( m.start() )
</code></pre>

<pre><code>## _
## 4
</code></pre>

<pre><code class="python">import re
addresses = [&quot;john@att.com&quot;, &quot;stat243@bspace.berkeley.edu&quot;, 
  &quot;john_smith3@att.com&quot;]
print( re.findall(&quot;[\d_]+&quot;, addresses[2]) )
</code></pre>

<pre><code>## [&#39;_&#39;, &#39;3&#39;]
</code></pre>

<p>To ignore case, do the following:</p>

<pre><code class="python">import re
str = &quot;That cat in the Hat&quot;
print( re.findall(&quot;hat&quot;, str, re.IGNORECASE) )
</code></pre>

<pre><code>## [&#39;hat&#39;, &#39;Hat&#39;]
</code></pre>

<p>We can of course use list comprehension to work with multiple strings. But we need to be careful to check whether a match was found.</p>

<pre><code class="python">import re
addresses = [&quot;john@att.com&quot;, &quot;stat243@bspace.berkeley.edu&quot;, 
  &quot;john_smith3@att.com&quot;]

def return_group(pattern, txt):
    m = re.search(pattern, txt)
    if m:
       return(m.group())
    else:
       return(None)

print( [return_group(&quot;[\d_]+&quot;, txt) for txt in addresses] )
</code></pre>

<pre><code>## [None, &#39;243&#39;, &#39;_&#39;]
</code></pre>

<p>Next, let&#39;s look at replacing patterns.</p>

<pre><code class="python">import re
text = [&quot;john&quot;,&quot;holly pierce&quot;,&quot;Juan carlos rey&quot;]
print( re.sub(&quot;^j&quot;, &quot;J&quot;, text[0]) )
print( re.sub(&quot;^j&quot;, &quot;J&quot;, text[1]) )
</code></pre>

<pre><code>## John
## holly pierce
</code></pre>

<pre><code class="python">import re
text = &#39;&quot;H4NY07011&quot;,&quot;ACKERMAN, GARY L.&quot;,&quot;H&quot;,&quot;$13,242&quot;,,,&#39;
print( re.sub(&quot;([^\&quot;,]),&quot;, &quot;\\1&quot;, text) )
</code></pre>

<pre><code>## &quot;H4NY07011&quot;,&quot;ACKERMAN GARY L.&quot;,&quot;H&quot;,&quot;$13242&quot;,,,
</code></pre>

<p>Finally, let&#39;s see the consequences of greedy matching and use of <code>?</code> to avoid greeding matching.</p>

<pre><code class="python">import re
text = &quot;Do an internship &lt;b&gt; in place &lt;/b&gt; of &lt;b&gt; one &lt;/b&gt; course.&quot;
print( re.sub(&quot;&lt;.*&gt;&quot;, &quot;&quot;, text) )
print( re.sub(&quot;&lt;.*?&gt;&quot;, &quot;&quot;, text) )
</code></pre>

<pre><code>## Do an internship  course.
## Do an internship  in place  of  one  course.
</code></pre>

<h3>3.2.2) Other comments</h3>

<p>You can also compile regex patterns for faster processing when working with a pattern multiple times.</p>

<pre><code class="python">import re
addresses = [&quot;john@att.com&quot;, &quot;stat243@bspace.berkeley.edu&quot;, &quot;john_smith3@att.com&quot;]
p = re.compile(&#39;\d+&#39;)
m = p.search(addresses[1])
print( m.group() )
</code></pre>

<pre><code>## 243
</code></pre>

<p>For reasons explained in the <a href="https://docs.python.org/2/howto/regex.html">re documentation</a>, to match an actual backslash, such as <code>&quot;\section&quot;</code>, you&#39;d need <code>&quot;\\\\section&quot;</code>. This can be avoided by using raw strings: <code>r&quot;\\section&quot;</code>.</p>

<h1>4) Webscraping and formatted text files</h1>

<p>There are lots of packages in both R and Python for downloading, reading in, and parsing formatted text files, such as HTML, XML, and JSON, as well as for submitting HTTP requests. So make sure you don&#39;t reinvent the wheel of what is already out there. </p>

<p>For R, some useful packages are <em>httr</em> and <em>RCurl</em> are good for interacting with webpages and <em>XML</em> for reading/parsing HTML and XML files. <em>jsonlite</em> is good for reading/parsing JSON. See the <a href="https://cran.r-project.org/web/views/WebTechnologies.html">WebTechnologies CRAN task view</a> for a summary.</p>

<p>For Python, the <em>requests</em> module is good for interacting with webpages. For XML and HTML, <em>lxml</em> is good, in particular <em>lxml.etree</em> and <em>lxml.html</em>.  For HTML, one might also use <em>HTMLParser</em> in Python 2.7 and <em>html.parser</em> in Python 3, and for XML there is also the <em>xml</em> module. <em>json</em> is good for reading/parsing JSON files.</p>

</body>

</html>
